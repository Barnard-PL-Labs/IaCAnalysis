Resources:
  demogqlapiApiLogsRole81FC96E8:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - :iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ApiLogsRole/Resource
  demogqlapiE10F9A29:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      AuthenticationType: API_KEY
      Name: demo-api-demo
      AdditionalAuthenticationProviders: []
      LogConfig:
        CloudWatchLogsRoleArn:
          Fn::GetAtt:
            - demogqlapiApiLogsRole81FC96E8
            - Arn
        FieldLogLevel: ERROR
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/Resource
  demogqlapiDevTestingOnlyApiKeyCE40C237:
    Type: AWS::AppSync::ApiKey
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      Description: Dev Testing Only
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/Dev Testing OnlyApiKey
  demogqlapiSchemaB4777EA9:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      Definition: |
        type Customer {
          id: ID!
          firstName: String!
          lastName: String!
          active: Boolean!
          address: String!
          _version: Int!
          _deleted: Boolean
          _lastChangedAt: AWSTimestamp!
        }

        type Product {
          id: ID!
          name: String!
          description: String!
          price: String!
          active: Boolean!
          added: AWSDateTime!
          _version: Int!
          _deleted: Boolean
          _lastChangedAt: AWSTimestamp!
        }

        type Order {
          id: ID!
          productID: ID!
          total: String!
          ordered: AWSDateTime!
          _version: Int!
          _deleted: Boolean
          _lastChangedAt: AWSTimestamp!
        }

        enum ModelSortDirection {
          ASC
          DESC
        }

        type ModelCustomerConnection {
          items: [Customer]
          nextToken: String
          startedAt: AWSTimestamp
        }

        input ModelStringInput {
          ne: String
          eq: String
          le: String
          lt: String
          ge: String
          gt: String
          contains: String
          notContains: String
          between: [String]
          beginsWith: String
          attributeExists: Boolean
          attributeType: ModelAttributeTypes
          size: ModelSizeInput
        }

        input ModelIDInput {
          ne: ID
          eq: ID
          le: ID
          lt: ID
          ge: ID
          gt: ID
          contains: ID
          notContains: ID
          between: [ID]
          beginsWith: ID
          attributeExists: Boolean
          attributeType: ModelAttributeTypes
          size: ModelSizeInput
        }

        input ModelIntInput {
          ne: Int
          eq: Int
          le: Int
          lt: Int
          ge: Int
          gt: Int
          between: [Int]
          attributeExists: Boolean
          attributeType: ModelAttributeTypes
        }

        input ModelFloatInput {
          ne: Float
          eq: Float
          le: Float
          lt: Float
          ge: Float
          gt: Float
          between: [Float]
          attributeExists: Boolean
          attributeType: ModelAttributeTypes
        }

        input ModelBooleanInput {
          ne: Boolean
          eq: Boolean
          attributeExists: Boolean
          attributeType: ModelAttributeTypes
        }

        input ModelSizeInput {
          ne: Int
          eq: Int
          le: Int
          lt: Int
          ge: Int
          gt: Int
          between: [Int]
        }

        input ModelCustomerFilterInput {
          id: ModelIDInput
          firstName: ModelStringInput
          lastName: ModelStringInput
          active: ModelBooleanInput
          address: ModelStringInput
          and: [ModelCustomerFilterInput]
          or: [ModelCustomerFilterInput]
          not: ModelCustomerFilterInput
        }

        type Query {
          syncCustomers(filter: ModelCustomerFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelCustomerConnection
          getCustomer(id: ID!): Customer
          listCustomers(filter: ModelCustomerFilterInput, limit: Int, nextToken: String): ModelCustomerConnection
          syncProducts(filter: ModelProductFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelProductConnection
          getProduct(id: ID!): Product
          listProducts(filter: ModelProductFilterInput, limit: Int, nextToken: String): ModelProductConnection
          syncOrders(filter: ModelOrderFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelOrderConnection
          getOrder(id: ID!, productID: ID!): Order
          listOrders(id: ID, productID: ModelIDKeyConditionInput, filter: ModelOrderFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelOrderConnection
        }

        input CreateCustomerInput {
          id: ID
          firstName: String!
          lastName: String!
          active: Boolean!
          address: String!
          _version: Int
        }

        input UpdateCustomerInput {
          id: ID!
          firstName: String
          lastName: String
          active: Boolean
          address: String
          _version: Int
        }

        input DeleteCustomerInput {
          id: ID
          _version: Int
        }

        type Mutation {
          createCustomer(input: CreateCustomerInput!, condition: ModelCustomerConditionInput): Customer
          updateCustomer(input: UpdateCustomerInput!, condition: ModelCustomerConditionInput): Customer
          deleteCustomer(input: DeleteCustomerInput!, condition: ModelCustomerConditionInput): Customer
          createProduct(input: CreateProductInput!, condition: ModelProductConditionInput): Product
          updateProduct(input: UpdateProductInput!, condition: ModelProductConditionInput): Product
          deleteProduct(input: DeleteProductInput!, condition: ModelProductConditionInput): Product
          createOrder(input: CreateOrderInput!, condition: ModelOrderConditionInput): Order
          updateOrder(input: UpdateOrderInput!, condition: ModelOrderConditionInput): Order
          deleteOrder(input: DeleteOrderInput!, condition: ModelOrderConditionInput): Order
        }

        input ModelCustomerConditionInput {
          firstName: ModelStringInput
          lastName: ModelStringInput
          active: ModelBooleanInput
          address: ModelStringInput
          and: [ModelCustomerConditionInput]
          or: [ModelCustomerConditionInput]
          not: ModelCustomerConditionInput
        }

        enum ModelAttributeTypes {
          binary
          binarySet
          bool
          list
          map
          number
          numberSet
          string
          stringSet
          _null
        }

        type Subscription {
          onCreateCustomer: Customer @aws_subscribe(mutations: ["createCustomer"])
          onUpdateCustomer: Customer @aws_subscribe(mutations: ["updateCustomer"])
          onDeleteCustomer: Customer @aws_subscribe(mutations: ["deleteCustomer"])
          onCreateProduct: Product @aws_subscribe(mutations: ["createProduct"])
          onUpdateProduct: Product @aws_subscribe(mutations: ["updateProduct"])
          onDeleteProduct: Product @aws_subscribe(mutations: ["deleteProduct"])
          onCreateOrder: Order @aws_subscribe(mutations: ["createOrder"])
          onUpdateOrder: Order @aws_subscribe(mutations: ["updateOrder"])
          onDeleteOrder: Order @aws_subscribe(mutations: ["deleteOrder"])
        }

        type ModelProductConnection {
          items: [Product]
          nextToken: String
          startedAt: AWSTimestamp
        }

        input ModelProductFilterInput {
          id: ModelIDInput
          name: ModelStringInput
          description: ModelStringInput
          price: ModelStringInput
          active: ModelBooleanInput
          added: ModelStringInput
          and: [ModelProductFilterInput]
          or: [ModelProductFilterInput]
          not: ModelProductFilterInput
        }

        input CreateProductInput {
          id: ID
          name: String!
          description: String!
          price: String!
          active: Boolean!
          added: AWSDateTime!
          _version: Int
        }

        input UpdateProductInput {
          id: ID!
          name: String
          description: String
          price: String
          active: Boolean
          added: AWSDateTime
          _version: Int
        }

        input DeleteProductInput {
          id: ID
          _version: Int
        }

        input ModelProductConditionInput {
          name: ModelStringInput
          description: ModelStringInput
          price: ModelStringInput
          active: ModelBooleanInput
          added: ModelStringInput
          and: [ModelProductConditionInput]
          or: [ModelProductConditionInput]
          not: ModelProductConditionInput
        }

        type ModelOrderConnection {
          items: [Order]
          nextToken: String
          startedAt: AWSTimestamp
        }

        input ModelOrderFilterInput {
          id: ModelIDInput
          productID: ModelIDInput
          total: ModelStringInput
          ordered: ModelStringInput
          and: [ModelOrderFilterInput]
          or: [ModelOrderFilterInput]
          not: ModelOrderFilterInput
        }

        input CreateOrderInput {
          id: ID
          productID: ID!
          total: String!
          ordered: AWSDateTime!
          _version: Int
        }

        input UpdateOrderInput {
          id: ID!
          productID: ID!
          total: String
          ordered: AWSDateTime
          _version: Int
        }

        input DeleteOrderInput {
          id: ID!
          productID: ID!
          _version: Int
        }

        input ModelOrderConditionInput {
          total: ModelStringInput
          ordered: ModelStringInput
          and: [ModelOrderConditionInput]
          or: [ModelOrderConditionInput]
          not: ModelOrderConditionInput
        }

        input ModelIDKeyConditionInput {
          eq: ID
          le: ID
          lt: ID
          ge: ID
          gt: ID
          between: [ID]
          beginsWith: ID
        }
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/Schema
  demogqlapiCustomerTableDSServiceRole339DF37E:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
        Version: "2012-10-17"
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/ServiceRole/Resource
  demogqlapiCustomerTableDSServiceRoleDefaultPolicy0655B372:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:BatchWriteItem
              - dynamodb:PutItem
              - dynamodb:UpdateItem
              - dynamodb:DeleteItem
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - CustomerTable260DCC08
                  - Arn
              - Ref: AWS::NoValue
          - Action: dynamodb:*
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - synctable882CE9F7
                - Arn
        Version: "2012-10-17"
      PolicyName: demogqlapiCustomerTableDSServiceRoleDefaultPolicy0655B372
      Roles:
        - Ref: demogqlapiCustomerTableDSServiceRole339DF37E
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/ServiceRole/DefaultPolicy/Resource
  demogqlapiCustomerTableDS5C8CDAAC:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      Name: CustomerTable
      Type: AMAZON_DYNAMODB
      Description: Data source for CustomerTable
      DynamoDBConfig:
        AwsRegion:
          Ref: AWS::Region
        DeltaSyncConfig:
          BaseTableTTL: "43200"
          DeltaSyncTableName:
            Ref: synctable882CE9F7
          DeltaSyncTableTTL: "30"
        TableName:
          Ref: CustomerTable260DCC08
        Versioned: true
      ServiceRoleArn:
        Fn::GetAtt:
          - demogqlapiCustomerTableDSServiceRole339DF37E
          - Arn
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/Resource
  demogqlapiCustomerTableDSMutationcreateCustomerResolverC879F82A:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: createCustomer
      TypeName: Mutation
      DataSourceName: CustomerTable
      Kind: UNIT
      RequestMappingTemplate: |-
        ## [Start] Prepare DynamoDB PutItem Request. **
        $util.qr($context.args.input.put("createdAt", $util.defaultIfNull($ctx.args.input.createdAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("updatedAt", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("__typename", "Customer"))
        #set( $condition = {
          "expression": "attribute_not_exists(#id)",
          "expressionNames": {
              "#id": "id"
          }
        } )
        #if( $context.args.condition )
          #set( $condition.expressionValues = {} )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        {
          "version": "2018-05-29",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": $util.toJson($condition)
        }
        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiCustomerTableDS5C8CDAAC
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/MutationcreateCustomerResolver/Resource
  demogqlapiCustomerTableDSMutationdeleteCustomerResolverDCF8A12D:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: deleteCustomer
      TypeName: Mutation
      DataSourceName: CustomerTable
      Kind: UNIT
      RequestMappingTemplate: |-
        #if( $authCondition )
          #set( $condition = $authCondition )
          #if( $modelObjectKey )
            #foreach( $entry in $modelObjectKey.entrySet() )
              $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#id)"))
            $util.qr($condition.expressionNames.put("#id", "id"))
          #end
        #else
          #if( $modelObjectKey )
            #set( $condition = {
          "expression": "",
          "expressionNames": {}
        } )
            #foreach( $entry in $modelObjectKey.entrySet() )
              #if( $velocityCount == 1 )
                $util.qr($condition.put("expression", "attribute_exists(#keyCondition$velocityCount)"))
              #else
                $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              #end
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            #set( $condition = {
          "expression": "attribute_exists(#id)",
          "expressionNames": {
              "#id": "id"
          }
        } )
          #end
        #end
        #if( $versionedCondition )
          $util.qr($condition.put("expression", "($condition.expression) AND $versionedCondition.expression"))
          $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
          #set( $expressionValues = $util.defaultIfNull($condition.expressionValues, {}) )
          $util.qr($expressionValues.putAll($versionedCondition.expressionValues))
          #set( $condition.expressionValues = $expressionValues )
        #end
        #if( $context.args.condition )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          #set( $conditionExpressionValues = $util.defaultIfNull($condition.expressionValues, {}) )
          $util.qr($conditionExpressionValues.putAll($conditionFilterExpressions.expressionValues))
          #set( $condition.expressionValues = $conditionExpressionValues )
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        {
          "version": "2018-05-29",
          "operation": "DeleteItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
        } #end,
          "condition": $util.toJson($condition),
          "_version": $util.defaultIfNull($ctx.args.input["_version"], "0")
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiCustomerTableDS5C8CDAAC
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/MutationdeleteCustomerResolver/Resource
  demogqlapiCustomerTableDSMutationupdateCustomerResolver98AEEB18:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: updateCustomer
      TypeName: Mutation
      DataSourceName: CustomerTable
      Kind: UNIT
      RequestMappingTemplate: |-
        #if( $authCondition && $authCondition.expression != "" )
          #set( $condition = $authCondition )
          #if( $modelObjectKey )
            #foreach( $entry in $modelObjectKey.entrySet() )
              $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#id)"))
            $util.qr($condition.expressionNames.put("#id", "id"))
          #end
        #else
          #if( $modelObjectKey )
            #set( $condition = {
          "expression": "",
          "expressionNames": {},
          "expressionValues": {}
        } )
            #foreach( $entry in $modelObjectKey.entrySet() )
              #if( $velocityCount == 1 )
                $util.qr($condition.put("expression", "attribute_exists(#keyCondition$velocityCount)"))
              #else
                $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              #end
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            #set( $condition = {
          "expression": "attribute_exists(#id)",
          "expressionNames": {
              "#id": "id"
          },
          "expressionValues": {}
        } )
          #end
        #end
        ## Automatically set the updatedAt timestamp. **
        $util.qr($context.args.input.put("updatedAt", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("__typename", "Customer"))
        ## Update condition if type is @versioned **
        #if( $versionedCondition )
          $util.qr($condition.put("expression", "($condition.expression) AND $versionedCondition.expression"))
          $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
          $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))
        #end
        #if( $context.args.condition )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        #set( $expNames = {} )
        #set( $expValues = {} )
        #set( $expSet = {} )
        #set( $expAdd = {} )
        #set( $expRemove = [] )
        #if( $modelObjectKey )
          #set( $keyFields = [] )
          #foreach( $entry in $modelObjectKey.entrySet() )
            $util.qr($keyFields.add("$entry.key"))
          #end
        #else
          #set( $keyFields = ["id", "_version", "_deleted", "_lastChangedAt"] )
        #end
        #foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )
          #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey("$entry.key") )
            #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get("$entry.key") )
          #else
            #set( $entryKeyAttributeName = $entry.key )
          #end
          #if( $util.isNull($entry.value) )
            #set( $discard = $expRemove.add("#$entryKeyAttributeName") )
            $util.qr($expNames.put("#$entryKeyAttributeName", "$entry.key"))
          #else
            $util.qr($expSet.put("#$entryKeyAttributeName", ":$entryKeyAttributeName"))
            $util.qr($expNames.put("#$entryKeyAttributeName", "$entry.key"))
            $util.qr($expValues.put(":$entryKeyAttributeName", $util.dynamodb.toDynamoDB($entry.value)))
          #end
        #end
        #set( $expression = "" )
        #if( !$expSet.isEmpty() )
          #set( $expression = "SET" )
          #foreach( $entry in $expSet.entrySet() )
            #set( $expression = "$expression $entry.key = $entry.value" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #if( !$expAdd.isEmpty() )
          #set( $expression = "$expression ADD" )
          #foreach( $entry in $expAdd.entrySet() )
            #set( $expression = "$expression $entry.key $entry.value" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #if( !$expRemove.isEmpty() )
          #set( $expression = "$expression REMOVE" )
          #foreach( $entry in $expRemove )
            #set( $expression = "$expression $entry" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #set( $update = {} )
        $util.qr($update.put("expression", "$expression"))
        #if( !$expNames.isEmpty() )
          $util.qr($update.put("expressionNames", $expNames))
        #end
        #if( !$expValues.isEmpty() )
          $util.qr($update.put("expressionValues", $expValues))
        #end
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": {
              "S": $util.toJson($context.args.input.id)
          }
        } #end,
          "update": $util.toJson($update),
          "condition": $util.toJson($condition),
          "_version": $util.defaultIfNull($ctx.args.input["_version"], "0")
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiCustomerTableDS5C8CDAAC
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/MutationupdateCustomerResolver/Resource
  demogqlapiCustomerTableDSQuerygetCustomerResolver4585303E:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: getCustomer
      TypeName: Query
      DataSourceName: CustomerTable
      Kind: UNIT
      RequestMappingTemplate: |-
        {
          "version": "2018-05-29",
          "operation": "GetItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
        } #end
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiCustomerTableDS5C8CDAAC
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/QuerygetCustomerResolver/Resource
  demogqlapiCustomerTableDSQuerylistCustomersResolverDD6B9785:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: listCustomers
      TypeName: Query
      DataSourceName: CustomerTable
      Kind: UNIT
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $ListRequest = {
          "version": "2018-05-29",
          "limit": $limit
        } )
        #if( $context.args.nextToken )
          #set( $ListRequest.nextToken = $context.args.nextToken )
        #end
        #if( $context.args.filter )
          #set( $ListRequest.filter = $util.parseJson("$util.transform.toDynamoDBFilterExpression($ctx.args.filter)") )
        #end
        #if( !$util.isNull($modelQueryExpression)
                                && !$util.isNullOrEmpty($modelQueryExpression.expression) )
          $util.qr($ListRequest.put("operation", "Query"))
          $util.qr($ListRequest.put("query", $modelQueryExpression))
          #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == "DESC" )
            #set( $ListRequest.scanIndexForward = false )
          #else
            #set( $ListRequest.scanIndexForward = true )
          #end
        #else
          $util.qr($ListRequest.put("operation", "Scan"))
        #end
        $util.toJson($ListRequest)
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiCustomerTableDS5C8CDAAC
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/QuerylistCustomersResolver/Resource
  demogqlapiCustomerTableDSQuerysyncCustomersResolver0E3D242A:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: syncCustomers
      TypeName: Query
      DataSourceName: CustomerTable
      Kind: UNIT
      RequestMappingTemplate: |-
        {
          "version": "2018-05-29",
          "operation": "Sync",
          "limit": $util.defaultIfNull($ctx.args.limit, 100),
          "nextToken": $util.toJson($util.defaultIfNull($ctx.args.nextToken, null)),
          "lastSync": $util.toJson($util.defaultIfNull($ctx.args.lastSync, null)),
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiCustomerTableDS5C8CDAAC
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/CustomerTableDS/QuerysyncCustomersResolver/Resource
  demogqlapiProductTableDSServiceRole82B3E382:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
        Version: "2012-10-17"
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/ServiceRole/Resource
  demogqlapiProductTableDSServiceRoleDefaultPolicyE5D3C86D:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:BatchWriteItem
              - dynamodb:PutItem
              - dynamodb:UpdateItem
              - dynamodb:DeleteItem
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - ProductTableB8D4E9ED
                  - Arn
              - Ref: AWS::NoValue
          - Action: dynamodb:*
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - synctable882CE9F7
                - Arn
        Version: "2012-10-17"
      PolicyName: demogqlapiProductTableDSServiceRoleDefaultPolicyE5D3C86D
      Roles:
        - Ref: demogqlapiProductTableDSServiceRole82B3E382
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/ServiceRole/DefaultPolicy/Resource
  demogqlapiProductTableDS32DB3703:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      Name: ProductTable
      Type: AMAZON_DYNAMODB
      Description: Data source for ProductTable
      DynamoDBConfig:
        AwsRegion:
          Ref: AWS::Region
        DeltaSyncConfig:
          BaseTableTTL: "43200"
          DeltaSyncTableName:
            Ref: synctable882CE9F7
          DeltaSyncTableTTL: "30"
        TableName:
          Ref: ProductTableB8D4E9ED
        Versioned: true
      ServiceRoleArn:
        Fn::GetAtt:
          - demogqlapiProductTableDSServiceRole82B3E382
          - Arn
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/Resource
  demogqlapiProductTableDSMutationcreateProductResolverEF3E81A3:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: createProduct
      TypeName: Mutation
      DataSourceName: ProductTable
      Kind: UNIT
      RequestMappingTemplate: |-
        ## [Start] Prepare DynamoDB PutItem Request. **
        $util.qr($context.args.input.put("createdAt", $util.defaultIfNull($ctx.args.input.createdAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("updatedAt", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("__typename", "Product"))
        #set( $condition = {
          "expression": "attribute_not_exists(#id)",
          "expressionNames": {
              "#id": "id"
          }
        } )
        #if( $context.args.condition )
          #set( $condition.expressionValues = {} )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        {
          "version": "2018-05-29",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": $util.toJson($condition)
        }
        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiProductTableDS32DB3703
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/MutationcreateProductResolver/Resource
  demogqlapiProductTableDSMutationdeleteProductResolver5D6CF25A:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: deleteProduct
      TypeName: Mutation
      DataSourceName: ProductTable
      Kind: UNIT
      RequestMappingTemplate: |-
        #if( $authCondition )
          #set( $condition = $authCondition )
          #if( $modelObjectKey )
            #foreach( $entry in $modelObjectKey.entrySet() )
              $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#id)"))
            $util.qr($condition.expressionNames.put("#id", "id"))
          #end
        #else
          #if( $modelObjectKey )
            #set( $condition = {
          "expression": "",
          "expressionNames": {}
        } )
            #foreach( $entry in $modelObjectKey.entrySet() )
              #if( $velocityCount == 1 )
                $util.qr($condition.put("expression", "attribute_exists(#keyCondition$velocityCount)"))
              #else
                $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              #end
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            #set( $condition = {
          "expression": "attribute_exists(#id)",
          "expressionNames": {
              "#id": "id"
          }
        } )
          #end
        #end
        #if( $versionedCondition )
          $util.qr($condition.put("expression", "($condition.expression) AND $versionedCondition.expression"))
          $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
          #set( $expressionValues = $util.defaultIfNull($condition.expressionValues, {}) )
          $util.qr($expressionValues.putAll($versionedCondition.expressionValues))
          #set( $condition.expressionValues = $expressionValues )
        #end
        #if( $context.args.condition )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          #set( $conditionExpressionValues = $util.defaultIfNull($condition.expressionValues, {}) )
          $util.qr($conditionExpressionValues.putAll($conditionFilterExpressions.expressionValues))
          #set( $condition.expressionValues = $conditionExpressionValues )
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        {
          "version": "2018-05-29",
          "operation": "DeleteItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
        } #end,
          "condition": $util.toJson($condition),
          "_version": $util.defaultIfNull($ctx.args.input["_version"], "0")
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiProductTableDS32DB3703
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/MutationdeleteProductResolver/Resource
  demogqlapiProductTableDSMutationupdateProductResolver37D05A3B:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: updateProduct
      TypeName: Mutation
      DataSourceName: ProductTable
      Kind: UNIT
      RequestMappingTemplate: |-
        #if( $authCondition && $authCondition.expression != "" )
          #set( $condition = $authCondition )
          #if( $modelObjectKey )
            #foreach( $entry in $modelObjectKey.entrySet() )
              $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#id)"))
            $util.qr($condition.expressionNames.put("#id", "id"))
          #end
        #else
          #if( $modelObjectKey )
            #set( $condition = {
          "expression": "",
          "expressionNames": {},
          "expressionValues": {}
        } )
            #foreach( $entry in $modelObjectKey.entrySet() )
              #if( $velocityCount == 1 )
                $util.qr($condition.put("expression", "attribute_exists(#keyCondition$velocityCount)"))
              #else
                $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              #end
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            #set( $condition = {
          "expression": "attribute_exists(#id)",
          "expressionNames": {
              "#id": "id"
          },
          "expressionValues": {}
        } )
          #end
        #end
        ## Automatically set the updatedAt timestamp. **
        $util.qr($context.args.input.put("updatedAt", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("__typename", "Product"))
        ## Update condition if type is @versioned **
        #if( $versionedCondition )
          $util.qr($condition.put("expression", "($condition.expression) AND $versionedCondition.expression"))
          $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
          $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))
        #end
        #if( $context.args.condition )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        #set( $expNames = {} )
        #set( $expValues = {} )
        #set( $expSet = {} )
        #set( $expAdd = {} )
        #set( $expRemove = [] )
        #if( $modelObjectKey )
          #set( $keyFields = [] )
          #foreach( $entry in $modelObjectKey.entrySet() )
            $util.qr($keyFields.add("$entry.key"))
          #end
        #else
          #set( $keyFields = ["id", "_version", "_deleted", "_lastChangedAt"] )
        #end
        #foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )
          #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey("$entry.key") )
            #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get("$entry.key") )
          #else
            #set( $entryKeyAttributeName = $entry.key )
          #end
          #if( $util.isNull($entry.value) )
            #set( $discard = $expRemove.add("#$entryKeyAttributeName") )
            $util.qr($expNames.put("#$entryKeyAttributeName", "$entry.key"))
          #else
            $util.qr($expSet.put("#$entryKeyAttributeName", ":$entryKeyAttributeName"))
            $util.qr($expNames.put("#$entryKeyAttributeName", "$entry.key"))
            $util.qr($expValues.put(":$entryKeyAttributeName", $util.dynamodb.toDynamoDB($entry.value)))
          #end
        #end
        #set( $expression = "" )
        #if( !$expSet.isEmpty() )
          #set( $expression = "SET" )
          #foreach( $entry in $expSet.entrySet() )
            #set( $expression = "$expression $entry.key = $entry.value" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #if( !$expAdd.isEmpty() )
          #set( $expression = "$expression ADD" )
          #foreach( $entry in $expAdd.entrySet() )
            #set( $expression = "$expression $entry.key $entry.value" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #if( !$expRemove.isEmpty() )
          #set( $expression = "$expression REMOVE" )
          #foreach( $entry in $expRemove )
            #set( $expression = "$expression $entry" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #set( $update = {} )
        $util.qr($update.put("expression", "$expression"))
        #if( !$expNames.isEmpty() )
          $util.qr($update.put("expressionNames", $expNames))
        #end
        #if( !$expValues.isEmpty() )
          $util.qr($update.put("expressionValues", $expValues))
        #end
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": {
              "S": $util.toJson($context.args.input.id)
          }
        } #end,
          "update": $util.toJson($update),
          "condition": $util.toJson($condition),
          "_version": $util.defaultIfNull($ctx.args.input["_version"], "0")
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiProductTableDS32DB3703
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/MutationupdateProductResolver/Resource
  demogqlapiProductTableDSQuerygetProductResolverC120024E:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: getProduct
      TypeName: Query
      DataSourceName: ProductTable
      Kind: UNIT
      RequestMappingTemplate: |-
        {
          "version": "2018-05-29",
          "operation": "GetItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
        } #end
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiProductTableDS32DB3703
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/QuerygetProductResolver/Resource
  demogqlapiProductTableDSQuerylistProductsResolver703A8020:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: listProducts
      TypeName: Query
      DataSourceName: ProductTable
      Kind: UNIT
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $ListRequest = {
          "version": "2018-05-29",
          "limit": $limit
        } )
        #if( $context.args.nextToken )
          #set( $ListRequest.nextToken = $context.args.nextToken )
        #end
        #if( $context.args.filter )
          #set( $ListRequest.filter = $util.parseJson("$util.transform.toDynamoDBFilterExpression($ctx.args.filter)") )
        #end
        #if( !$util.isNull($modelQueryExpression)
                                && !$util.isNullOrEmpty($modelQueryExpression.expression) )
          $util.qr($ListRequest.put("operation", "Query"))
          $util.qr($ListRequest.put("query", $modelQueryExpression))
          #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == "DESC" )
            #set( $ListRequest.scanIndexForward = false )
          #else
            #set( $ListRequest.scanIndexForward = true )
          #end
        #else
          $util.qr($ListRequest.put("operation", "Scan"))
        #end
        $util.toJson($ListRequest)
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiProductTableDS32DB3703
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/QuerylistProductsResolver/Resource
  demogqlapiProductTableDSQuerysyncProductsResolver5795AC2D:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: syncProducts
      TypeName: Query
      DataSourceName: ProductTable
      Kind: UNIT
      RequestMappingTemplate: |-
        {
          "version": "2018-05-29",
          "operation": "Sync",
          "limit": $util.defaultIfNull($ctx.args.limit, 100),
          "nextToken": $util.toJson($util.defaultIfNull($ctx.args.nextToken, null)),
          "lastSync": $util.toJson($util.defaultIfNull($ctx.args.lastSync, null)),
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiProductTableDS32DB3703
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/ProductTableDS/QuerysyncProductsResolver/Resource
  demogqlapiOrderTableDSServiceRoleD58C55C4:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
        Version: "2012-10-17"
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/ServiceRole/Resource
  demogqlapiOrderTableDSServiceRoleDefaultPolicy11D3EA89:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:BatchWriteItem
              - dynamodb:PutItem
              - dynamodb:UpdateItem
              - dynamodb:DeleteItem
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - OrderTable416EB896
                  - Arn
              - Ref: AWS::NoValue
          - Action: dynamodb:*
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - synctable882CE9F7
                - Arn
        Version: "2012-10-17"
      PolicyName: demogqlapiOrderTableDSServiceRoleDefaultPolicy11D3EA89
      Roles:
        - Ref: demogqlapiOrderTableDSServiceRoleD58C55C4
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/ServiceRole/DefaultPolicy/Resource
  demogqlapiOrderTableDSAEE4B7BF:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      Name: OrderTable
      Type: AMAZON_DYNAMODB
      Description: Data source for OrderTable
      DynamoDBConfig:
        AwsRegion:
          Ref: AWS::Region
        DeltaSyncConfig:
          BaseTableTTL: "43200"
          DeltaSyncTableName:
            Ref: synctable882CE9F7
          DeltaSyncTableTTL: "30"
        TableName:
          Ref: OrderTable416EB896
        Versioned: true
      ServiceRoleArn:
        Fn::GetAtt:
          - demogqlapiOrderTableDSServiceRoleD58C55C4
          - Arn
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/Resource
  demogqlapiOrderTableDSMutationcreateOrderResolverB6D14F02:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: createOrder
      TypeName: Mutation
      DataSourceName: OrderTable
      Kind: UNIT
      RequestMappingTemplate: |-
        ## [Start] Set the primary @key. **
        #set( $modelObjectKey = {
          "id": $util.dynamodb.toDynamoDB($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId())),
          "productID": $util.dynamodb.toDynamoDB($ctx.args.input.productID)
        } )
        ## [End] Set the primary @key. **

        ## [Start] Prepare DynamoDB PutItem Request. **
        $util.qr($context.args.input.put("createdAt", $util.defaultIfNull($ctx.args.input.createdAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("updatedAt", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("__typename", "Order"))
        #set( $condition = {
          "expression": "attribute_not_exists(#id)",
          "expressionNames": {
              "#id": "id"
          }
        } )
        #if( $context.args.condition )
          #set( $condition.expressionValues = {} )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": $util.toJson($condition)
        }
        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiOrderTableDSAEE4B7BF
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/MutationcreateOrderResolver/Resource
  demogqlapiOrderTableDSMutationdeleteOrderResolver0FB3AE8F:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: deleteOrder
      TypeName: Mutation
      DataSourceName: OrderTable
      Kind: UNIT
      RequestMappingTemplate: |-
        ## [Start] Set the primary @key. **
        #set( $modelObjectKey = {
          "id": $util.dynamodb.toDynamoDB($ctx.args.input.id),
          "productID": $util.dynamodb.toDynamoDB($ctx.args.input.productID)
        } )
        ## [End] Set the primary @key. **
        #if( $authCondition )
          #set( $condition = $authCondition )
          #if( $modelObjectKey )
            #foreach( $entry in $modelObjectKey.entrySet() )
              $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#id)"))
            $util.qr($condition.expressionNames.put("#id", "id"))
          #end
        #else
          #if( $modelObjectKey )
            #set( $condition = {
          "expression": "",
          "expressionNames": {}
        } )
            #foreach( $entry in $modelObjectKey.entrySet() )
              #if( $velocityCount == 1 )
                $util.qr($condition.put("expression", "attribute_exists(#keyCondition$velocityCount)"))
              #else
                $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              #end
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            #set( $condition = {
          "expression": "attribute_exists(#id)",
          "expressionNames": {
              "#id": "id"
          }
        } )
          #end
        #end
        #if( $versionedCondition )
          $util.qr($condition.put("expression", "($condition.expression) AND $versionedCondition.expression"))
          $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
          #set( $expressionValues = $util.defaultIfNull($condition.expressionValues, {}) )
          $util.qr($expressionValues.putAll($versionedCondition.expressionValues))
          #set( $condition.expressionValues = $expressionValues )
        #end
        #if( $context.args.condition )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          #set( $conditionExpressionValues = $util.defaultIfNull($condition.expressionValues, {}) )
          $util.qr($conditionExpressionValues.putAll($conditionFilterExpressions.expressionValues))
          #set( $condition.expressionValues = $conditionExpressionValues )
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        {
          "version": "2018-05-29",
          "operation": "DeleteItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
        } #end,
          "condition": $util.toJson($condition),
          "_version": $util.defaultIfNull($ctx.args.input["_version"], "0")
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiOrderTableDSAEE4B7BF
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/MutationdeleteOrderResolver/Resource
  demogqlapiOrderTableDSMutationupdateOrderResolver61971553:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: updateOrder
      TypeName: Mutation
      DataSourceName: OrderTable
      Kind: UNIT
      RequestMappingTemplate: |-
        ## [Start] Set the primary @key. **
        #set( $modelObjectKey = {
          "id": $util.dynamodb.toDynamoDB($ctx.args.input.id),
          "productID": $util.dynamodb.toDynamoDB($ctx.args.input.productID)
        } )
        ## [End] Set the primary @key. **

        #if( $authCondition && $authCondition.expression != "" )
          #set( $condition = $authCondition )
          #if( $modelObjectKey )
            #foreach( $entry in $modelObjectKey.entrySet() )
              $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#id)"))
            $util.qr($condition.expressionNames.put("#id", "id"))
          #end
        #else
          #if( $modelObjectKey )
            #set( $condition = {
          "expression": "",
          "expressionNames": {},
          "expressionValues": {}
        } )
            #foreach( $entry in $modelObjectKey.entrySet() )
              #if( $velocityCount == 1 )
                $util.qr($condition.put("expression", "attribute_exists(#keyCondition$velocityCount)"))
              #else
                $util.qr($condition.put("expression", "$condition.expression AND attribute_exists(#keyCondition$velocityCount)"))
              #end
              $util.qr($condition.expressionNames.put("#keyCondition$velocityCount", "$entry.key"))
            #end
          #else
            #set( $condition = {
          "expression": "attribute_exists(#id)",
          "expressionNames": {
              "#id": "id"
          },
          "expressionValues": {}
        } )
          #end
        #end
        ## Automatically set the updatedAt timestamp. **
        $util.qr($context.args.input.put("updatedAt", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))
        $util.qr($context.args.input.put("__typename", "Order"))
        ## Update condition if type is @versioned **
        #if( $versionedCondition )
          $util.qr($condition.put("expression", "($condition.expression) AND $versionedCondition.expression"))
          $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))
          $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))
        #end
        #if( $context.args.condition )
          #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )
          $util.qr($condition.put("expression", "($condition.expression) AND $conditionFilterExpressions.expression"))
          $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))
          $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))
        #end
        #if( $condition.expressionValues && $condition.expressionValues.size() == 0 )
          #set( $condition = {
          "expression": $condition.expression,
          "expressionNames": $condition.expressionNames
        } )
        #end
        #set( $expNames = {} )
        #set( $expValues = {} )
        #set( $expSet = {} )
        #set( $expAdd = {} )
        #set( $expRemove = [] )
        #if( $modelObjectKey )
          #set( $keyFields = [] )
          #foreach( $entry in $modelObjectKey.entrySet() )
            $util.qr($keyFields.add("$entry.key"))
          #end
        #else
          #set( $keyFields = ["id", "_version", "_deleted", "_lastChangedAt"] )
        #end
        #foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )
          #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey("$entry.key") )
            #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get("$entry.key") )
          #else
            #set( $entryKeyAttributeName = $entry.key )
          #end
          #if( $util.isNull($entry.value) )
            #set( $discard = $expRemove.add("#$entryKeyAttributeName") )
            $util.qr($expNames.put("#$entryKeyAttributeName", "$entry.key"))
          #else
            $util.qr($expSet.put("#$entryKeyAttributeName", ":$entryKeyAttributeName"))
            $util.qr($expNames.put("#$entryKeyAttributeName", "$entry.key"))
            $util.qr($expValues.put(":$entryKeyAttributeName", $util.dynamodb.toDynamoDB($entry.value)))
          #end
        #end
        #set( $expression = "" )
        #if( !$expSet.isEmpty() )
          #set( $expression = "SET" )
          #foreach( $entry in $expSet.entrySet() )
            #set( $expression = "$expression $entry.key = $entry.value" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #if( !$expAdd.isEmpty() )
          #set( $expression = "$expression ADD" )
          #foreach( $entry in $expAdd.entrySet() )
            #set( $expression = "$expression $entry.key $entry.value" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #if( !$expRemove.isEmpty() )
          #set( $expression = "$expression REMOVE" )
          #foreach( $entry in $expRemove )
            #set( $expression = "$expression $entry" )
            #if( $foreach.hasNext() )
              #set( $expression = "$expression," )
            #end
          #end
        #end
        #set( $update = {} )
        $util.qr($update.put("expression", "$expression"))
        #if( !$expNames.isEmpty() )
          $util.qr($update.put("expressionNames", $expNames))
        #end
        #if( !$expValues.isEmpty() )
          $util.qr($update.put("expressionValues", $expValues))
        #end
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": {
              "S": $util.toJson($context.args.input.id)
          }
        } #end,
          "update": $util.toJson($update),
          "condition": $util.toJson($condition),
          "_version": $util.defaultIfNull($ctx.args.input["_version"], "0")
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiOrderTableDSAEE4B7BF
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/MutationupdateOrderResolver/Resource
  demogqlapiOrderTableDSQuerygetOrderResolver1C6A24EE:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: getOrder
      TypeName: Query
      DataSourceName: OrderTable
      Kind: UNIT
      RequestMappingTemplate: |-
        ## [Start] Set the primary @key. **
        #set( $modelObjectKey = {
          "id": $util.dynamodb.toDynamoDB($ctx.args.id),
          "productID": $util.dynamodb.toDynamoDB($ctx.args.productID)
        } )
        ## [End] Set the primary @key. **
        {
          "version": "2018-05-29",
          "operation": "GetItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
        } #end
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiOrderTableDSAEE4B7BF
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/QuerygetOrderResolver/Resource
  demogqlapiOrderTableDSQuerylistOrdersResolverFB563A43:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: listOrders
      TypeName: Query
      DataSourceName: OrderTable
      Kind: UNIT
      RequestMappingTemplate: |-
        ## [Start] Set query expression for @key **
        #set( $modelQueryExpression = {} )
        ## [Start] Validate key arguments. **
        #if( !$util.isNull($ctx.args.productID) && $util.isNull($ctx.args.id) )
          $util.error("When providing argument 'productID' you must also provide arguments id", "InvalidArgumentsError")
        #end
        ## [End] Validate key arguments. **
        #if( !$util.isNull($ctx.args.id) )
          #set( $modelQueryExpression.expression = "#id = :id" )
          #set( $modelQueryExpression.expressionNames = {
          "#id": "id"
        } )
          #set( $modelQueryExpression.expressionValues = {
          ":id": {
              "S": "$ctx.args.id"
          }
        } )
        #end
        ## [Start] Applying Key Condition **
        #if( !$util.isNull($ctx.args.productID) && !$util.isNull($ctx.args.productID.beginsWith) )
          #set( $modelQueryExpression.expression = "$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)" )
          $util.qr($modelQueryExpression.expressionNames.put("#sortKey", "productID"))
          $util.qr($modelQueryExpression.expressionValues.put(":sortKey", { "S": "$ctx.args.productID.beginsWith" }))
        #end
        #if( !$util.isNull($ctx.args.productID) && !$util.isNull($ctx.args.productID.between) )
          #set( $modelQueryExpression.expression = "$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1" )
          $util.qr($modelQueryExpression.expressionNames.put("#sortKey", "productID"))
          $util.qr($modelQueryExpression.expressionValues.put(":sortKey0", { "S": "$ctx.args.productID.between[0]" }))
          $util.qr($modelQueryExpression.expressionValues.put(":sortKey1", { "S": "$ctx.args.productID.between[1]" }))
        #end
        #if( !$util.isNull($ctx.args.productID) && !$util.isNull($ctx.args.productID.eq) )
          #set( $modelQueryExpression.expression = "$modelQueryExpression.expression AND #sortKey = :sortKey" )
          $util.qr($modelQueryExpression.expressionNames.put("#sortKey", "productID"))
          $util.qr($modelQueryExpression.expressionValues.put(":sortKey", { "S": "$ctx.args.productID.eq" }))
        #end
        #if( !$util.isNull($ctx.args.productID) && !$util.isNull($ctx.args.productID.lt) )
          #set( $modelQueryExpression.expression = "$modelQueryExpression.expression AND #sortKey < :sortKey" )
          $util.qr($modelQueryExpression.expressionNames.put("#sortKey", "productID"))
          $util.qr($modelQueryExpression.expressionValues.put(":sortKey", { "S": "$ctx.args.productID.lt" }))
        #end
        #if( !$util.isNull($ctx.args.productID) && !$util.isNull($ctx.args.productID.le) )
          #set( $modelQueryExpression.expression = "$modelQueryExpression.expression AND #sortKey <= :sortKey" )
          $util.qr($modelQueryExpression.expressionNames.put("#sortKey", "productID"))
          $util.qr($modelQueryExpression.expressionValues.put(":sortKey", { "S": "$ctx.args.productID.le" }))
        #end
        #if( !$util.isNull($ctx.args.productID) && !$util.isNull($ctx.args.productID.gt) )
          #set( $modelQueryExpression.expression = "$modelQueryExpression.expression AND #sortKey > :sortKey" )
          $util.qr($modelQueryExpression.expressionNames.put("#sortKey", "productID"))
          $util.qr($modelQueryExpression.expressionValues.put(":sortKey", { "S": "$ctx.args.productID.gt" }))
        #end
        #if( !$util.isNull($ctx.args.productID) && !$util.isNull($ctx.args.productID.ge) )
          #set( $modelQueryExpression.expression = "$modelQueryExpression.expression AND #sortKey >= :sortKey" )
          $util.qr($modelQueryExpression.expressionNames.put("#sortKey", "productID"))
          $util.qr($modelQueryExpression.expressionValues.put(":sortKey", { "S": "$ctx.args.productID.ge" }))
        #end
        ## [End] Applying Key Condition **
        ## [End] Set query expression for @key **
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $ListRequest = {
          "version": "2018-05-29",
          "limit": $limit
        } )
        #if( $context.args.nextToken )
          #set( $ListRequest.nextToken = $context.args.nextToken )
        #end
        #if( $context.args.filter )
          #set( $ListRequest.filter = $util.parseJson("$util.transform.toDynamoDBFilterExpression($ctx.args.filter)") )
        #end
        #if( !$util.isNull($modelQueryExpression)
                                && !$util.isNullOrEmpty($modelQueryExpression.expression) )
          $util.qr($ListRequest.put("operation", "Query"))
          $util.qr($ListRequest.put("query", $modelQueryExpression))
          #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == "DESC" )
            #set( $ListRequest.scanIndexForward = false )
          #else
            #set( $ListRequest.scanIndexForward = true )
          #end
        #else
          $util.qr($ListRequest.put("operation", "Scan"))
        #end
        $util.toJson($ListRequest)
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiOrderTableDSAEE4B7BF
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/QuerylistOrdersResolver/Resource
  demogqlapiOrderTableDSQuerysyncOrdersResolverE10D02DE:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
          - demogqlapiE10F9A29
          - ApiId
      FieldName: syncOrders
      TypeName: Query
      DataSourceName: OrderTable
      Kind: UNIT
      RequestMappingTemplate: |-
        {
          "version": "2018-05-29",
          "operation": "Sync",
          "limit": $util.defaultIfNull($ctx.args.limit, 100),
          "nextToken": $util.toJson($util.defaultIfNull($ctx.args.nextToken, null)),
          "lastSync": $util.toJson($util.defaultIfNull($ctx.args.lastSync, null)),
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end
        }
      ResponseMappingTemplate: |-
        #if( $ctx.error )
        $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
        #else
        $util.toJson($ctx.result)
        #end
    DependsOn:
      - demogqlapiOrderTableDSAEE4B7BF
      - demogqlapiSchemaB4777EA9
    Metadata:
      aws:cdk:path: AppStack/demo-gql-api/OrderTableDS/QuerysyncOrdersResolver/Resource
  synctable882CE9F7:
    Type: AWS::DynamoDB::Table
    Properties:
      KeySchema:
        - AttributeName: ds_pk
          KeyType: HASH
        - AttributeName: ds_sk
          KeyType: RANGE
      AttributeDefinitions:
        - AttributeName: ds_pk
          AttributeType: S
        - AttributeName: ds_sk
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: _ttl
        Enabled: true
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    Metadata:
      aws:cdk:path: AppStack/sync-table/Resource
  CustomerTable260DCC08:
    Type: AWS::DynamoDB::Table
    Properties:
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: _ttl
        Enabled: true
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    Metadata:
      aws:cdk:path: AppStack/CustomerTable/Resource
  ProductTableB8D4E9ED:
    Type: AWS::DynamoDB::Table
    Properties:
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: _ttl
        Enabled: true
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    Metadata:
      aws:cdk:path: AppStack/ProductTable/Resource
  OrderTable416EB896:
    Type: AWS::DynamoDB::Table
    Properties:
      KeySchema:
        - AttributeName: id
          KeyType: HASH
        - AttributeName: productID
          KeyType: RANGE
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: productID
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: _ttl
        Enabled: true
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    Metadata:
      aws:cdk:path: AppStack/OrderTable/Resource
  CDKMetadata:
    Type: AWS::CDK::Metadata
    Properties:
      Modules: aws-cdk=2.113.0,@aws-cdk/assets=1.31.0,@aws-cdk/aws-applicationautoscaling=1.31.0,@aws-cdk/aws-appsync=1.31.0,@aws-cdk/aws-autoscaling=1.31.0,@aws-cdk/aws-autoscaling-common=1.31.0,@aws-cdk/aws-autoscaling-hooktargets=1.31.0,@aws-cdk/aws-cloudformation=1.31.0,@aws-cdk/aws-cloudwatch=1.31.0,@aws-cdk/aws-dynamodb=1.31.0,@aws-cdk/aws-ec2=1.31.0,@aws-cdk/aws-ecr=1.31.0,@aws-cdk/aws-ecr-assets=1.31.0,@aws-cdk/aws-ecs=1.31.0,@aws-cdk/aws-elasticloadbalancingv2=1.31.0,@aws-cdk/aws-events=1.31.0,@aws-cdk/aws-iam=1.31.0,@aws-cdk/aws-kms=1.31.0,@aws-cdk/aws-lambda=1.31.0,@aws-cdk/aws-logs=1.31.0,@aws-cdk/aws-s3=1.31.0,@aws-cdk/aws-s3-assets=1.31.0,@aws-cdk/aws-servicediscovery=1.31.0,@aws-cdk/aws-sns=1.31.0,@aws-cdk/aws-sns-subscriptions=1.31.0,@aws-cdk/aws-sqs=1.31.0,@aws-cdk/aws-ssm=1.31.0,@aws-cdk/aws-stepfunctions=1.31.0,@aws-cdk/aws-stepfunctions-tasks=1.31.0,@aws-cdk/core=1.31.0,@aws-cdk/custom-resources=1.31.0,@aws-cdk/cx-api=1.31.0,@aws-cdk/region-info=1.31.0,jsii-runtime=node.js/v18.12.1
    Condition: CDKMetadataAvailable
Conditions:
  CDKMetadataAvailable:
    Fn::Or:
      - Fn::Or:
          - Fn::Equals:
              - Ref: AWS::Region
              - af-south-1
          - Fn::Equals:
              - Ref: AWS::Region
              - ap-east-1
          - Fn::Equals:
              - Ref: AWS::Region
              - ap-northeast-1
          - Fn::Equals:
              - Ref: AWS::Region
              - ap-northeast-2
          - Fn::Equals:
              - Ref: AWS::Region
              - ap-south-1
          - Fn::Equals:
              - Ref: AWS::Region
              - ap-southeast-1
          - Fn::Equals:
              - Ref: AWS::Region
              - ap-southeast-2
          - Fn::Equals:
              - Ref: AWS::Region
              - ca-central-1
          - Fn::Equals:
              - Ref: AWS::Region
              - cn-north-1
          - Fn::Equals:
              - Ref: AWS::Region
              - cn-northwest-1
      - Fn::Or:
          - Fn::Equals:
              - Ref: AWS::Region
              - eu-central-1
          - Fn::Equals:
              - Ref: AWS::Region
              - eu-north-1
          - Fn::Equals:
              - Ref: AWS::Region
              - eu-south-1
          - Fn::Equals:
              - Ref: AWS::Region
              - eu-west-1
          - Fn::Equals:
              - Ref: AWS::Region
              - eu-west-2
          - Fn::Equals:
              - Ref: AWS::Region
              - eu-west-3
          - Fn::Equals:
              - Ref: AWS::Region
              - il-central-1
          - Fn::Equals:
              - Ref: AWS::Region
              - me-central-1
          - Fn::Equals:
              - Ref: AWS::Region
              - me-south-1
          - Fn::Equals:
              - Ref: AWS::Region
              - sa-east-1
      - Fn::Or:
          - Fn::Equals:
              - Ref: AWS::Region
              - us-east-1
          - Fn::Equals:
              - Ref: AWS::Region
              - us-east-2
          - Fn::Equals:
              - Ref: AWS::Region
              - us-west-1
          - Fn::Equals:
              - Ref: AWS::Region
              - us-west-2

